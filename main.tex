\documentclass{article}
\input{pream}
\begin{document}
\maketitle
\section*{Disclaimer}

These are my personal notes and are not official course documents. They may contain inaccuracies or omissions, hence, they should not be considered as a substitute for official course materials or as comprehensive preparation for examinations.

\tableofcontents

\clearpage
\section{Introduction and Basic Data Types}
We call the data \textbf{Tabular} when there are no modelled dependencies between attributes, for example, demographic attributes such as age, gender, ZIP code, etc. (also called \textit{Nondependency-Oriented Data}). Otherwise it is \textbf{Non-Tabular}, e.g. social networks, time series, etc.

\textbf{Matrix Representation of Data}

A set  $X = \{ X_i \mid  i \in \{1 \dots n \}\}, $ with $n$ records (samples) is a $d$-dimensional dataset iff each sample $X_i$ is a set of $\{ x_j \mid j \in \{ 1 \dots d\} \}$ attributes (features). $X$ is tabular if it is invariant w.r.t shuffling of samples and features. Each feature $x_j$ has its own domain $\mathcal{D}_j$

\mydef{Quantitative vs. Categorical}{A variable $x$ is quantitative (numeric) if its domain $\mathcal{D}_x$ is numeric. Otherwise, Categorical.
\textit{Examples (Q): }age, weight, height, BMI, Date of Birth.
\textit{Examples (C): }name, gender, country, ZIP Code, weather, ID, day.}

\mydef{Nominal vs. Ordinal}{A categorical variable $x$ is ordinal if its domain $\mathcal{D}_x$ has a natural ordering. Otherwise, Nominal.
\textit{Examples (N): }weather, name, gender, country, ZIP, ID, day
\textit{Examples (O): }heat level, textual gpa.}

\mydef{Finite vs. Infinite}{A variable $x$ has a finite domain iff $|\mathcal{D}_x| = N , N \in \mathbb{N}$. Otherwise, Infinite.
\textit{Examples (F): }age (years), country, ZIP, ID, gender, day.
\textit{Examples (I): }BMI, height, Date of Birth.}

\commandnote{All categorical variables have finite domains, not the other way around.}

\mydef{Discrete vs. Cont.}{A Quantitative variable $x$ is continuous iff $\forall z,y \in \mathcal{D}_x \exists w \in \mathcal{D}_x, z<w<y$. Otherwise, Discrete.
\textit{Examples (D): }age (years, months, days, hours, etc).
\textit{Examples (C): }age (unitless, number), Date of Birth (point in cont. time), BMI.}

\commandnote{By \textbf{rounding} quantitative data, we can transform cont. domains into discrete ones.}
\commandnote{Age is quantitative finite discrete if it is computed as whole years, months, days, hours. However, it is quantitative infinite continuous it is computed as precise value including fractions}
\commandnote{Date of Birth is quantitative infinite continuous since it is a point in a continuous endless time}

\mydef{Binary}{We call a variable $x$ binary iff $|\mathcal{D}_x|=2$}

\mydef{Temporal}{We call a variable $x$ temporal iff $\mathcal{D}_x$ represents time points or intervals. \textit{Examples:} day, month, Date of Birth}

\mydef{Encoding}{Data Encoding refers to the technique of converting data into a form that allows it to be properly used by different systems.}

\mydef{Binning}{Binning is an encoding technique that is a function $f : \mathcal{D} \to \{1 \dots K\}$}

\mydef{Example: Equal-Width Binning}{Size (width) of each bin is calculated as $W = \frac{\text{Max}(x)-\text{Min}(x)}{K}$ where $K$ is the number of bins.} 

\minititle{One-Hot Encoding}
To mitigate the problem of label encoding for nominal variables.\\
\textbf{How?} Create a fixed-size vector with size = $|\text{unique}(x)|$, where each position corresponds to a unique category value. Assign a \texttt{1} to the position representing the category and \texttt{0}s elsewhere.

\textbf{Example:}
Suppose $\text{unique}(x) = \{\text{Red}, \text{Green}, \text{Blue}\}$

\begin{itemize}
    \item Red $\rightarrow$ [1, 0, 0]
    \item Green $\rightarrow$ [0, 1, 0]
    \item Blue $\rightarrow$ [0, 0, 1]
\end{itemize}

\commandnote{
    One-hot encoding avoids the problem of implying ordinal relationships.
    However, it increases dimensionality significantly, especially when the number of categories is large (curse of dimensionality).
}

\minititle{Cyclic Encoding}
Some categorical variables are \textit{ordinal} and have a natural \textit{cyclic} structure. A classic example is the months of the year:
\[
\mathcal{D}_x = \{\text{Jan}, \text{Feb}, \dots, \text{Dec}\}
\]

This variable has both an order (Jan $<$ Feb $<$ ... $<$ Dec) and a cyclic relationship (Dec is followed by Jan).

To encode this properly, we use the index \( i \) of each category in the ordered list, where \( i = 1, 2, \dots, k \), and \( k \) is the total number of categories.

\textbf{Encoding Function:}
\[
\text{enc}(c_i) = (x_i, y_i)
\]
\[
x_i = \cos\left(\frac{2\pi(i-1)}{k}\right),\quad y_i = \sin\left(\frac{2\pi(i-1)}{k}\right)
\]

This maps each category to a unique point on the unit circle, preserving both order and cyclicity.

\commandnote{
    Cyclic encoding is useful when the first and last categories are conceptually adjacent (e.g., December and January). This is not possible with standard label or one-hot encoding.
}
\textbf{Optional: Normalize to Unit Square}
\[
\text{enc}(c_i) = \left(\frac{x_i + 1}{2},\ \frac{y_i + 1}{2}\right)
\]
This scaled version maps points to the square $[0, 1] \times [0, 1]$, which can be useful when input normalization is required for machine learning models. Note that this transformation alters the original unit circle geometry.

\commandnote{
    Use raw unit circle encoding when preserving angular distance is important. Use the normalized version when the model expects features in the range $[0, 1]$.
}   

\minititle{Non-Tabular Data}
Such as Spatial data, images, time series, string, graphs.

A set $X = \{x_i \mid i \in \{1 \dots n\}\}$ is a $d$-dimensional \textbf{spatial} dataset with $n$ samples if each sample $x_i$ contains a set of $\{ x_j \mid j \in \{ 1 \dots d\} \}$  features AND each data point $x_{ij}$ is associated with a specific spatial location $l$.

A spatial location $l$ can be a point $(l_x, l_y) \in \mathbb{R}^2$ (2D spatial data) or $(l_x, l_y, l_z) \in \mathbb{R}^3$ (3D spatial data), etc.

\minititle{Tokenization (Character-Level)}

Tokenization is the process of converting raw text into smaller units called tokens. In character-level tokenization, each unique character from the corpus is treated as a token.

\textbf{Example:} Consider the corpus consisting of a single sentence:  
\texttt{"hi ai"}

\begin{itemize}
    \item Unique characters: \texttt{\{h, i, \space, a\}}  
    \item Assign token IDs: \texttt{h:0,\ i:1,\space:2,\ a:3}
    \item Tokenized sentence: \texttt{"hi ai"} $\rightarrow$ \texttt{[0, 1, 2, 3, 1]}
\end{itemize}

Each character in the sentence is replaced by its corresponding token ID.

\minititle{Graphs}

A graph is a mathematical structure used to model pairwise relations between objects.

\begin{itemize}
    \item A graph \( G \) is defined as \( G = (V, E) \), where:
    \begin{itemize}
        \item \( V \) is a set of \textit{vertices} (or \textit{nodes}).
        \item \( E \subseteq V \times V \) is a set of \textit{edges}.
    \end{itemize}
\end{itemize}

\textbf{Types of Graphs:}
\begin{itemize}
    \item \textbf{Undirected Graph:}  
    An edge \( (u, v) \in E \) implies a bidirectional connection:  
    \[
    (u, v) \in E \Rightarrow (v, u) \in E
    \]

    \item \textbf{Directed Graph (Digraph):}  
    Edges have direction:  
    \[
    (u, v) \in E \not\Rightarrow (v, u) \in E
    \]
\end{itemize}

\minititle{Graph Representations}

\textbf{Adjacency Matrix:}

A \( |V| \times |V| \) matrix \( A \), where:
\[
A[u][v] = 
\begin{cases}
1 & \text{if } (u,v) \in E \\
0 & \text{otherwise}
\end{cases}
\]

\begin{itemize}
    \item \textbf{Space consumption:} \( \mathcal{O}(|V|^2) \)
    \item \textbf{Edge access:} \( \mathcal{O}(1) \)
    \item \textbf{Neighbor iteration:} \( \mathcal{O}(|V|) \)
\end{itemize}

\textbf{Adjacency List:}

Each vertex \( u \in V \) maintains a list of its neighbors.

\begin{itemize}
    \item \textbf{Space consumption:} \( \mathcal{O}(|V| + |E|) \)
    \item \textbf{Edge access:} \( \mathcal{O}(|V|) \) (worst-case search)
    \item \textbf{Neighbor iteration:} \( \mathcal{O}(\deg(u)) \), where \( \deg(u) \) is the degree of vertex \( u \)
\end{itemize}

    \textbf{Weighted Graphs:}  

    In some graphs, each edge \( (u, v) \in E \) is associated with a numerical value called a \textit{weight}, often representing cost, distance, capacity, etc.
    
    \begin{itemize}
        \item For weighted graphs, the edge set becomes:  
        \[
        E \subseteq V \times V \times \mathbb{R}
        \]
        or we define a weight function:  
        \[
        w : E \rightarrow \mathbb{R}
        \]
        \item In the adjacency matrix, \( A[u][v] \) stores the weight instead of a binary 0 or 1.
        \item In the adjacency list, each neighbor can be stored along with its edge weight as a tuple: \( (v, w(u, v)) \).
    \end{itemize}   
\newpage
\section{Conceptual Modeling}
\mydef{ER Model}{Entity-Relationship Model is a high-level, conceptual framework to describe entities, their attributes, and the relationships between them.
}

\mydef{Entity}{Basic concept of the Entity-Relationship (ER) model. It is an object in the real world. E.g. e1 (some employee).}

\mydef{Attribute}{Entities have attributes that are the properties that describe them.}

\mydef{Entity Type}{All entities that have the same entity type share the same attributes. E.g. EMPLOYEE (type), e1 (Entity).}

\mydef{Attribute Value}{A particular entity has a specific value for each of its attributes.}

\mydef{Composite}{An attribute is composite if it is described in terms of its smaller parts. E.g. Name, some databases consider name as a composite attribute consisting of two \textbf{atomic} attributes First Name and Last Name.}

\mydef{Atomic/Simple}{Cannot be divided into smaller parts.}

\commandnote{
    These days, we store \textbf{date} as a single value attribute of the type \textit{DATE}. Earlier, date was considered as a composite attribute consisting of atomic attributes \textit{day, month, year}.
}

\mydef{Derived}{An attribute is derived if its value is calculated using other \textbf{stored} attributes, e.g. age.}

\mydef{Stored}{An attribute is stored if it cannot be derived from other attributes.}

\commandnote{
    Age is both derived and atomic. DateOfBirth is both composite and stored.
}

\mydef{Single-Valued}{An attribute is single-valued if it can have only one value. E.g. DateOfBirth is single-valued composite. Biological sex is single-valued atomic.}

\mydef{Multi-Valued}{An attribute is multivalued if it can have several values. E.g. college degrees is multivalued atomic and can have BSc, MSc, BEng, etc.}

\commandnote{
    Affiliation of an entity type RESEARCHER is multivalued (because one can have different affiliations) and composite because an affiliation could be represented as (Org. Name, Dept., Address, Role, Start Date, End Date).
}

\mydef{Entity Set}{Collection of entities of a particular entity type in a database in a given time point.}

\begin{tabular}{|l|l|} \hline
    Entity Type & Blueprint/Description \\ \hline
    Entity Set & Actual set of entities (entity instances) at a point in time \\ \hline
\end{tabular}
\commandnote{
    In ancient logic and philosophy we refer to the definition or conceptual content of a term as an \textit{intension}. However, the set of actual things that satisfy a concept is called \textit{extension}. Hence, Entity Type is called intension, Entity Set is called extension.
}

\mydef{Candidate Key (Key Attribute)}{A candidate key is an attribute (or set of attributes) that \textbf{uniquely} and \textbf{minimally} identifies each entity in an entity set. E.g. StudentID, studentEmail.}

\mydef{Primary Key}{A primary key is the chosen candidate key that will be used to uniquely identify entities in the database.}

\mydef{Foreign Key}{A foreign key is an attribute in one table/entity that references the primary key of another table/entity.
It expresses a relationship between two entity sets.}

\mydef{Composite Primary Key}{A composite primary key is a primary key that consists of two or more attributes combined together to uniquely identify a record in a table. Neither attribute alone is sufficient to guarantee uniqueness — but together, they do.}

This is common in relationship tables, for example: enrollment relationship between students and courses (M:M):

\begin{tabular}{|l|l|l|} \hline
    StudentID & CourseID & Grade \\ \hline
    101&CS101&A \\ \hline
    101&MATH201&B \\ \hline
    102&CS101&B+ \\ \hline
\end{tabular}

\mydef{Weak Entity Types}{Entity types without key attributes.}

\mydef{Strong Entity Types}{Entity types with key attributes.}

\subsection*{Relations}
If we want to model 1:M or M:1 relations, we use the idea of foreign key (modeling the relation with single value attribute). Examples:

\begin{tabular}{|l|l|} \hline
    PersonID & PersonName \\ \hline
    1&Alice\\ \hline
    2&Bob \\ \hline
\end{tabular}
\begin{tabular}{|l|l|} \hline
    categoryID & categoryName \\ \hline
    1&Sport\\ \hline
    2&Science \\ \hline
\end{tabular}
\begin{tabular}{|l|l|l|} \hline
    catID & catName & ownerID \\ \hline
    1&Daisy&1\\ \hline
    2&Smart&2 \\ \hline
    3&Sweet&1 \\ \hline
\end{tabular}
\begin{tabular}{|l|l|l|} \hline
    articleID & title & categoryID \\ \hline
    1&title&1\\ \hline
    2&title&2 \\ \hline
    3&title&1 \\ \hline
\end{tabular}

We model M:M Relations by creating an entity representing that relation (usually with composite primary key).

\mydef{Relationship Type}{The definition / template / blueprint of the relationship}

\mydef{Relationship Instance}{A single actual link between entities.}

\mydef{Relationship Set}{The collection of all relationship instances at a given time.}

\mydef{Participation}{We say that entity types $E_1 \dots E_n$ participate in the \textbf{relationship type} $R$.}

\mydef{Relationship Degree}{Number of participating entity types in the relation. E.g. consider a relation SUPPLY that models which suppliers supply which projects and what parts are supplied, the degree here is 3 due the three entity types (SUPPLIER, PROJECT, PART).}

\mydef{Role Name}{The name describing the part an entity plays in a relationship.}
 
\mydef{Recursive Relationship}{A relationship where the same entity type participates more than once with different roles. E.g. SUPERVISION.}

\mydef{Cardinality Ratio}{Specifies the maximum number of entities of one type that can be associated with an entity of another type in a relationship. Examples ($E_1$ BINARY\_RELATION $E_2$):}

Let $E_1$ and $E_2$ be the sets of entities of type $E_1$ and $E_2$, respectively. Let $R \subseteq E_1 \times E_2$ be the binary relation between them: $R = \{ (e_1, e_2) \mid e_1 \in E_1,\ e_2 \in E_2 \}$
\begin{itemize}
    \item \textbf{1:1 }each entity of type $E_1$ can be related to at most one entity of type $E_2$ and vice versa
    \[
    \forall e_1 \in E_1, \quad |\{ e_2 \in E_2 \mid (e_1, e_2) \in R \}| \leq 1
    \]
    \[
    \forall e_2 \in E_2, \quad |\{ e_1 \in E_1 \mid (e_1, e_2) \in R \}| \leq 1
    \]
    \item \textbf{1:M }one entity of type $E_1$ can be related to many entities of type $E_2$. Each entity of type $E_2$ can be related to at most one entity of type $E_1$
    \[
        \forall e_1 \in E_1, \quad |\{ e_2 \in E_2 \mid (e_1, e_2) \in R \}| \geq 0
        \]
        \[
        \forall e_2 \in E_2, \quad |\{ e_1 \in E_1 \mid (e_1, e_2) \in R \}| \leq 1
    \]
    \item \textbf{M:1 }Inverse of \textbf{1:M }
    \[
        \forall e_1 \in E_1, \quad |\{ e_2 \in E_2 \mid (e_1, e_2) \in R \}| \leq 1
        \]
        \[
        \forall e_2 \in E_2, \quad |\{ e_1 \in E_1 \mid (e_1, e_2) \in R \}| \geq 0
    \]
    \item \textbf{M:M }many entities of type $E_1$ can be related to many entities of type $E_2$ and vice versa
    \[
        \forall e_1 \in E_1, \quad |\{ e_2 \in E_2 \mid (e_1, e_2) \in R \}| \geq 0
        \]
        \[
        \forall e_2 \in E_2, \quad |\{ e_1 \in E_1 \mid (e_1, e_2) \in R \}| \geq 0
    \]
\end{itemize}

\textbf{Total vs. Partial Participation}
\begin{itemize}
    \item \textbf{Total Participation of } $E_1$ in $R$ \\
    $\forall e_1 \in E_1, \ \exists e_2 \in E_2 : (e_1, e_2) \in R$  
    (Every entity of $E_1$ is related to at least one entity of $E_2$.)

    \item \textbf{Partial Participation of } $E_1$ in $R$ \\
    $\exists e_1 \in E_1: \forall e_2 \in E_2, (e_1, e_2) \notin R$  
    (There exists an entity in $E_1$ that does not participate in $R$.)
\end{itemize}

\textbf{Migrating attributes from relations to entities:}
\begin{itemize}
    \item 1:1 relationship types: Attributes can be migrated to either participating entity. (e.g. EMP MANAGES DEPT, start\_date)
    \item 1:N or N:1 relationship types: Attributes should be migrated to the entity that participates at most once. (e.g. EMP WORKS\_FOR DEPT, start\_date)
    \item M:N relationship types: Attributes cannot be migrated to the participating entities and must remain on the relationship itself.
\end{itemize}

\mydef{Identifying Relationships}{a special relationship where a weak entity is identified by its relationship with a strong entity. The weak entity cannot exist without the strong entity, and the relationship plays a crucial role in providing the weak entity with a composite key.}

\mydef{Existence Dependency}{A weak entity depends on the strong entity for its existence. It cannot exist without being related to a strong entity.}

\commandnote{
    A weak entity type has total participation in its identifying relationship. This means that every instance of the weak entity must be associated with at least one instance of the strong entity. If it doesn't, the weak entity doesn't exist ("existence dependency").
}
Example: 
\begin{itemize}
    \item Consider we have the following strong entities, customer, product.
    \item To manage orders, we have two entities, order, orderItem.
    \item Order is a strong entity since each order has its ID
    \item However, OrderItem entity can have OrderID, LineNumber, ProductID, quantity, price, discount, etc.
    \item In this case, OrderItem entity is a weak one, it cannot exist unless an order exists, therefore, the primary key is composite (OrderID, LineNumber)
\end{itemize}

\mydef{Min-Max Modeling}{Given an entity $E$ participating in Relation $R$. If at least \textit{min} and at most \textit{max} instances of $E$ must participate in $R$ with $\textit{min}>=0, \textit{max}>=1, \textit{max}>=\textit{min}$, then we say $E$ respects min-max constraint (\textit{min}, \textit{max}) w.r.t $R$.
}

\minititle{ER Diagram}

\begin{figure}[H]
    \includegraphics[width=0.4\linewidth]{images/chens-notation-1.png}
\end{figure}
\newpage
\section{The Relational Data Model}
\mydef{Set}{
A set is a well-defined collection of distinct objects, considered as an object in its own right. The objects in a set are called elements or members. Sets are usually denoted by capital letters like $A$, $B$, or $S$, and elements are listed within curly braces. For example, $A = \set{1, 2, 3}$ is a set containing the numbers 1, 2, and 3.
}

\mydef{Element of a Set}{
If $x$ is an element of set $A$, we write $x \in A$. If $x$ is not in $A$, we write $x \notin A$.
}

\mydef{Set-builder Notation}{
Set-builder notation is a shorthand used to describe a set by stating the properties that its elements must satisfy.
For example: $\set{x \in \mathbb{N} \mid x \text{ is even} }$ describes the set of even natural numbers.
}

\mydef{Cardinality}{
The cardinality of a set is the number of elements in the set, denoted $|A|$.
For example, if $A = \set{1, 2, 3}$, then $|A| = 3$.
}

\mydef{Cartesian Product} {
Let $A$ and $B$ be sets, then $A \times B = \set{(a,b) \mid a \in A , b \in B}$, e.g. $A=\{1,2\}, B=\{x,y\}, A \times B = \set{(1,x),(1,y),(2,x),(2,y)}$
}

\mydef{Subset}{
$A\subseteq B \Leftrightarrow \forall X. X\in A \Rightarrow X \in B$
}

\mydef{Proper Subset}{
$A \subset B \Leftrightarrow A\subseteq B \land A \neq B$
}

\mydef{Relation}{
$R \subseteq A \times B$. If $(a,b) \in R$, we say that $a$ is related to $b$ via $R$
}

\mydef{Left Total Relation}{
A relation $R \subseteq A \times B$ is left total (total on $A$) iff each element in $A$ is related to at least on element in $B$. $\forall a \in A.  \exists b \in B. (a,b) \in R$
}

\mydef{Right Unique Relation}{
A relation $R \subseteq A \times B$ is right unique iff each element in $A$ is related to at most one element in $B$. $\forall a\in A, \forall b1, b2 \in B, ((a,b1) \in R,(a,b2)\in R) \Rightarrow b1 = b2$
}

\mydef{Function}{
A function is left total and right unique relation. $f:A \to B$
}

\mydef{Partial Function}{
A partial function is a right unique relation, \textbf{not} necessarily left total. $f \rightharpoonup B$
}

\mydef{Set Union}{
$x \in A \cup B \Leftrightarrow x \in A \text{ or }  x \in B$
}

\mydef{Set Intersection}{
$x \in A \cap B \Leftrightarrow x \in A \text{ and } x \in B$
}

\mydef{Disjoint}{
We say two sets $A,B$ are disjoint iff $A \cap B=\phi$
}

\mydef{Relation Schema}{A declaration $\textstyle R\bigl(A_1{:}D_1,\dots,A_n{:}D_n\bigr)$ consisting of a name $R$, a finite, non‑empty attribute set $\set{A_i}$ and, for each attribute, its domain $\operatorname{dom}(A_i)=D_i$.}

\mydef{Schema Satisfaction}{A \emph{tuple} $t=(v_1,\dots,v_n)$ \emph{satisfies} the schema if $v_i\in D_i\;\forall i$.}

\mydef{Types}{\textit{Classes} of atomic values that share representation and operations, e.g. \texttt{Int}, \texttt{Real}, or \texttt{String}.}

\mydef{Domain}{A \textit{set} of atomic values with application‑specific semantics whose underlying implementation type is fixed.  Domains may define default values.  Example: $\textit{EmployeeAge}=\texttt{Int}[18,65]$.}

\commandnote{Domain declaration examples: \texttt{Name = String(20)}, \texttt{DollarPrice = Decimal(5,2)}.}



\mydef{Instance}{A \emph{finite set} of tuples that all satisfy a given relation schema.  While the schema is comparatively stable (static), its instance is \emph{dynamic}: it evolves through insertions, deletions, and updates.}

\minititle{Two Equivalent Views on Tuples}

\begin{itemize}
    \item \textbf{Positional (Cartesian‑product) view:} $t$ is an \emph{ordered list} $\bigl(v_1,\dots,v_n\bigr)$.  Column order carries meaning; attribute names are implicit.
    \item \textbf{Functional view:} Fix $A=\set{A_1,\dots,A_n}$ and $D=\bigcup_i D_i$.  Then a tuple is a \emph{function} $t:A\to D$ with $t(A_i)\in D_i$.  Here, order is irrelevant and attribute names are explicit.
\end{itemize}

\mydef{Domain Constraint}{Each attribute value must lie in its declared domain $D_i$.  Usually enforced by the DBMS type checker.}

\mydef{Functional Dependency (FD)}{For attribute sets $X,Y\subseteq A$, the notation $X\to Y$ states: for any two tuples $t_1,t_2$, equality of $X$‑values implies equality of $Y$‑values.  Written out: $t_1[X]=t_2[X]\Rightarrow t_1[Y]=t_2[Y]$.}

\mydef{Superkey}{An attribute set $K$ with $K\to A$ (it functionally determines the whole tuple).}

\mydef{Candidate Key}{A \emph{minimal} superkey — removing any attribute from it destroys the functional determination of $A$.}

\mydef{Primary Key}{The candidate key chosen by the database designer to serve as the principal identifier of tuples in a relation.  Remaining candidate keys are called \emph{alternate keys}.}

% -- revised example ------------------------------------------------------
\minititle{Example}
\begin{itemize}
    \item Relation schema $\textit{Employee}(\textit{EmpID},\textit{SSN},\textit{Email},\textit{Name},\textit{Dept})$.
    \item \emph{Superkeys} include any attribute set that uniquely identifies tuples, e.g $\{\textit{EmpID}\},\;\{\textit{SSN}\},\;\{\textit{EmpID},\textit{Name}\}$. The third set still determines the whole tuple but is \emph{not} minimal.
    \item \emph{Candidate keys}: the minimal superkeys $\{\textit{EmpID}\}\quad\text{and}\quad\{\textit{SSN}\}$. Each is irreducible.
    \item \emph{Primary key}: suppose we designate $\textit{EmpID}$ as the primary key.  The other candidate becomes an \emph{alternate key} available for unique look‑ups.
\end{itemize}

\mydef{Foreign Key}{Attribute(s) in relation $R$ whose values must also appear as the primary-key values of another relation $S$ (ensuring referential integrity).}

\commandnote{When an insertion, deletion or modification would break any constraint, the DBMS may (i) reject the change or (ii) repair it automatically (``cascade'', insert default/null, etc.).  The exact behaviour is part of the schema definition.}



\subsection*{A word on modeling different cardinalities}
Relational databases use foreign keys (FKs) to represent associations between entities. The modeling depends on the cardinality:

\minititle{One-to-One (1:1)}
A FK is placed in one of the tables.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Person} & ID (PK) & Name & PassportID (FK) \\
\hline
 & 1 & Alice & 101 \\
\hline
\end{tabular}
\quad
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Passport} & ID (PK) & Number & DateOfIssue \\
\hline
 & 101 & X1234 & 2020-01-01 \\
\hline
\end{tabular}
\end{center}

\minititle{One-to-Many (1:M) or Many-to-One (M:1)}
The FK is placed in the table on the "many" side, referencing the "one" side.

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Department} & ID (PK) & Name \\
\hline
 & 1 & Human Resources \\
\hline
\end{tabular}
\quad
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Employee} & ID (PK) & Name & DepartmentID (FK) \\
\hline
 & 101 & John & 1 \\
\hline
\end{tabular}
\end{center}

\begin{center}
\end{center}

\minititle{Many-to-Many (M:M)}
Modeled via a relation table with two FKs, each referencing one of the related tables. The combination of FKs often serves as the primary key.

\begin{center}
    \begin{tabular}{|c|c|}
    \hline
    \textbf{StdID} & StdName \\
    \hline
    1 & Jane \\
    2 & Mark \\
    3 & Sara \\
    \hline
    \end{tabular}
    \quad
    \begin{tabular}{|c|c|}
    \hline
    \textbf{CourseID} & CourseTitle \\
    \hline
    10 & Database Systems \\
    11 & Operating Systems \\
    12 & Algorithms \\
    \hline
    \end{tabular}
    \quad
    \begin{tabular}{|c|c|}
    \hline
    \textbf{StdID} & \textbf{CourseID} \\
    \hline
    1 & 10 \\
    1 & 12 \\
    2 & 10 \\
    2 & 11 \\
    3 & 11 \\
    \hline
    \end{tabular}
    \end{center}

\newpage
\section{Functional Dependencies}
\mydef{Prime Attribute}{
An attribute that is part of any candidate key.
}

\mydef{Nonprime Attribute}{
An attribute that is not part of any candidate key.
}

\textbf{Example: }consider the simple relation \texttt{STUDENT(ID, Email, Name, Phone, CourseID)}. Possible super keys:
\[
\set{\texttt{ID}}, \set{\texttt{Email}}, \set{\texttt{ID}, \texttt{Name}}, \set{\texttt{ID}, \texttt{Email}, \texttt{Phone}}
\]
Only $\set{\texttt{ID}}$ and $\set{\texttt{Email}}$ are prime attributes.

\mydef{Trivial FD}{
We say that a functional dependency $X \to Y$ is \textbf{trivial} iff $Y \subseteq X$. 
}

\mydef{Full FD}{
A functional dependency $X \to Y$ is full iff for any $A \in X$, $(X-\set{A}) \to Y$ does not hold, i.e. you cannot remove any attribute from $X$ without breaking the dependency. Example: $\{$studentID, CourseID$\} \to $ Grade.
}

\mydef{Partial FD}{
A functional dependency $X \to Y$ is partial iff  $\exists A \in X$. $(X-\set{A}) \to Y$ holds.
}


\mydef{Transitive FD}{
A functional dependency $X \to Y$ is transitive in a relation $R$ iff $\exists \textbf{ Nonprime set of attributes } Z \in R$ and both $X \to Z$ and $Z \to Y$ hold.
}

\mydef{Inference}{
A functional dependency $X \to Y$ is \textbf{inferred} from a set of functional dependencies $F$ on a relation $R$ iff $X \to Y$ holds in every instance of $R$ that satisfies all dependencies in $F$
}

\minititle{Armstrong's Inference Rules for Functional Dependencies}
\begin{itemize}
    \item \textbf{IR1}: $(Y \subseteq X) \Rightarrow (X \to Y)$ (reflexive)
    \item \textbf{IR2}: $(X \to Y) \Rightarrow (X \cup Z \to Y \cup Z)$ (augmentation) 
    \item \textbf{IR3}: $((X \to Y) \land (Y \to Z)) \Rightarrow X \to Z$ (transitive) 
\end{itemize}

\mydef{Closure}{
The closure of attribute set $X$ under a set of functional dependencies $F$, denoted as $X_F^+$ is the set of all attributes that $X$ can determine using FDs in $F$. $X_F^+ = \set{A \mid X \to A \in F \text{ or can be inferred from it}}$ 
}

\minititle{Closure Algorithm}
\begin{itemize}
    \item input: a set $F$ of FDs on a relation $R$, and a set of attributes $X$ contained in $R$
    \item initialization: $X_F^+ = X$
    \item changed = True
    \item while changed:
    \begin{enumerate}
        \item changed = False
        \item for each FD $Y \to Z \in F$:
        \begin{enumerate}
            \item If $(Y \subseteq X_F^+) \land (Z \notin X_F^+)$:
            \begin{enumerate}
                \item $X_F^+ = X_F^+ \cup \set{Z}$
                \item changed = True
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
    \item Output: $X_F^+$
\end{itemize}

\mydef{FDs Verification}{
$F \text{ implies }X \to Y \textit{ iff } Y \subseteq X_F^+$
}

\mydef{Superkeys Verification}{
$X$ is a super key for $R$ with attribute set $U$ \textit{iff} $X_F^+ = U$
}
\newpage
\minititle{Finding Candidate Keys}
\begin{verbatim}
Input: Relation (R) over set of attributes (U), set of FDs (F)
initialization: K:= U
minimal = False
while not minimal
    minimal = True
    for each attribute A in K
        compute closure of (K-A) under F
            if the closure = U
                set K := K - {A}
                minimal = False
Return: K
\end{verbatim}

\mydef{Coverage}{
For any two sets of functional dependencies $F_1, F_2$, we say that $F_1$ covers $F_2$, \textit{iff}  $\forall X \to Y \in F_2. Y \subseteq X_{F_1}^+$.   
}


\mydef{Equivalence}{
For any two sets of functional dependencies $F_1, F_2$, we say they are equivalent, \textit{iff} they cover each other.   
}
Example: verify whether the following FDs are equivalent.
\begin{itemize}
    \item $F_1=\set{A \to C, AC \to D, E \to AD, E \to H}$ and
    \item $F_2 = \set{A \to CD, E \to AH}$
\end{itemize}
We check first if $F_1$ covers $F_2$
\begin{itemize}
    \item considering $A \to \set{C,D} \quad \set{C,D} \in A_{F_1}^+ = \set{A,C,D}$
    \item considering $E \to \set{A,H} \quad \set{A,H} \in E_{F_1}^+ = \set{E,A,D,H,C}$
    \item Hence $F_1$ covers $F_2$
\end{itemize}

Next, we check first if $F_2$ covers $F_1$
\begin{itemize}
    \item considering $A \to C \quad C \in A_{F_2}^+ = \set{C,D}$
    \item considering $\set{A,C} \to D \quad D \in \set{A,C}_{F_2}^+ = \set{A,C,D}$
    \item considering $E \to \set{A,D} \quad \set{A,D} \in E_{F_2}^+ = \set{A,H,C,D}$
    \item considering $E \to H \quad H \in E_{F_2}^+ = \set{A,H,C,D}$
    \item Hence $F_2$ covers $F_1$
\end{itemize}

Therefore, they are equivalent

\mydef{Redundancy}{
A functional dependency $f = X \to A$ is redundant in FDs set $F$ \textit{iff} $A \subseteq X_G^+$ where $G = F-\set{X \to A}$, i.e. $F - \set{f}$ implies $f$. 
}

\mydef{Extraneous}{
Given a set $F$ of FDs and one $f=AX \to B \in F$, then $A$ is extraneous if $B \subseteq X_F^+$
}


\mydef{Minimal cover}{
A set of FDs $F$ is a minimal cover of a set of FDs $E$ iff $F$ covers $E$ and there is no $f \in F. \quad F- \set{f}$ covers $E$
}

\mydef{Canonical}{
    A functional dependency $f=X \to Y$ is in a canonical form iff $|Y|=1$
}

\mydef{Minimal set of FDs}{
A set $F$ of FDs is minimal iff it satisfies the following conditions: (i) All FDs in a canonical form. (ii) No extraneous attributes. (iii) No redundant FDs.
}

\minititle{Steps to Obtain a Minimal Set of Functional Dependencies}
\begin{enumerate}
    \item Transform to Canonical form
    \item Remove Extraneous Attributes
    \item Remove Redundant FDs
\end{enumerate}

\newpage
\section{Relational Algebra and SQL}
\mydef{Data Model}{
    In relational databases, the data model specifies how data is structured and how it can be manipulated. i.e. it says that data is organized into tables (called relations) with columns (attributes) and rows (tuples).
}

\mydef{Relational model}{
    In relational databases, the relational model represent data as relations (tables). Each relation has constraints, such as keys or data types, to ensure data integrity.
}

\mydef{Relational Algebra}{
    The formal system for manipulating relations. It provides a theoretical foundation for \textbf{Query} operations used in relational databases
}

\mydef{Algebra}{
    A formal system in which expressions are constructed using operators and atomic operands. These expressions can be evaluated, and two expressions are considered equivalent if they yield the same result for all possible values of their operands.
}

\mydef{Relational Algebra}{
    A type of algebra where the operands are relations (tables), and the operators are defined for any instance of those relations. Operations can be combined to form complex expressions, and evaluating an expression produces a result schema (the structure of the output) and a result instance (the actual data produced).
}

\mydef{SQL}{
    The Standard Query Language (SQL) is the language used to interact with relational databases. It is a \textbf{declarative} language, meaning that when you write a query, you describe what result you want, not how the database should compute it. This contrasts with procedural languages, where you must specify every step.
}

\minititle{SQL Structure}
SQL is organized into several sub-languages, each serving a distinct purpose:
\begin{itemize}
    \item Data Definition Language (DDL): used to define or alter the structure of database objects. Commands used such as: \texttt{CREATE, ALTER, DROP}
    \item Data Manipulation Language (DML): used to retrieve and manipulate data. Command used such as: \texttt{SELECT, UPDATE, INSERT, DELETE}
    \item Data Control Language (DCL): manages user permissions and access control. Commands used such as: \texttt{GRANT, REVOKE}
    \item Transaction Control Language (TCL): manages database transactions. Commands used such as: \texttt{COMMIT ROLLBACK}
\end{itemize}

Example DML Queries:
\begin{verbatim}
    SELECT name, age FROM Student WHERE age >= 18 ORDER BY name ASC;
    
    INSERT INTO Student (stdId, name, age) VALUES (101, "Alice", 20);
    
    UPDATE Student SET age = age + 1 WHERE stdId = 101;

    DELETE FROM Student WHERE stdId = 101;
\end{verbatim}

Examples on \texttt{COUNT, DISTINCT, EXIST, IN}
\begin{verbatim}
    SELECT COUNT(*) FROM Student;

    SELECT COUNT(DISTINCT stdID) FROM Student; 
    
    SELECT * FROM employees e
    WHERE EXISTS (
        SELECT 1
        FROM bonus b
        WHERE b.employee_id = e.employee_id
    );

    SELECT * FROM employees WHERE department_id IN (1, 2, 5);

\end{verbatim}

\newpage
Example DDL Queries:
\begin{verbatim}
    CREATE TABLE Course (courceID INT PRIMARY KEY,
                         title    VARCHAR(100)
                        );

    ALTER TABLE Course ADD COLUMN credits INT;

    DROP TABLE Course;
\end{verbatim}

Example DCL Queries:
\begin{verbatim}
    GRANT SELECT, INSERT ON Student TO user1;

    REVOKE INSERT ON Student FROM user1;
\end{verbatim}

Example TCL Queries:
\begin{verbatim}
    BEGIN;
    UPDATE Account SET balance = balance - 100 WHERE id = 1;
    COMMIT; 
\end{verbatim}
Example Primary Key and Foreign Key:
\begin{verbatim}
CREATE TABLE Department (
    deptID INT PRIMARY KEY,
    deptName VARCHAR(100)
);

CREATE TABLE Employee (
    empID INT PRIMARY KEY,
    empName VARCHAR(100),
    deptID INT,
    FOREIGN KEY (deptID) REFERENCES Department(deptID)
);
\end{verbatim}

Example Composite Primary Key:
\begin{verbatim}
    CREATE TABLE Student (
    stdID INT PRIMARY KEY,
    stdName VARCHAR(100)
);

CREATE TABLE Course (
    crsID INT PRIMARY KEY,
    crsName VARCHAR(100)
);

CREATE TABLE Enrollment (
    stdID INT,
    crsID INT,
    grade CHAR(2),
    PRIMARY KEY (stdID, crsID),
    FOREIGN KEY (stdID) REFERENCES Student(stdID),
    FOREIGN KEY (crsID) REFERENCES Course(crsID)
);
\end{verbatim}

Example Domain Constraints:
\begin{verbatim}
CREATE TABLE Product (
    id INT PRIMARY KEY,
    price DECIMAL(10,2) CHECK (price >= 0),
    category VARCHAR(50) NOT NULL
);
\end{verbatim}

\minititle{Set Operators}
\mydef{Arity / Degree}{
let $R(A_1, \cdots, A_n)$ be a relation schema, the arity of $R$ is $\text{arity}(R)=n$
}

\mydef{Union Compatible}{
   We say that relations $R(A_1, \cdots, A_n)$ and $S(B_1, \cdots, B_n)$ are union compatible if $\text{artiy}(R) = \text{arity}(S)$ and $ \text{dom}(A_i)=\text{dom}(B_i) \quad \forall i \in \{1, \cdots, n\}$
}

\mydef{Relation Union}{$R_1 \cup R_2 = \set{t \mid t \in R_1 \lor t \in R_2}$. SQL Equiv.: \texttt{SELECT * FROM R UNION SELECT * FROM S}}



\mydef{Relation Intersection}{$R_1 \cap R_2 = \set{t \mid t \in R_1 \land t \in R_2}$. SQL: \texttt{SELECT * FROM R INTERSECT SELECT * FROM S}}

\mydef{Relation Difference}{$R_1 - R_2 = \set{t \mid t \in R_1 \land  t \notin R_2}$. SQL: \texttt{SELECT * FROM R EXCEPT SELECT * FROM S}}

\mydef{Relation Cartesian Product}{
$R_1 \times R_2 = \set{t_1 \circ t_2 \mid t_1 \in R_1,\ t_2 \in R_2}$. SQL: \texttt{SELECT * FROM R CROSS JOIN S}}

\minititle{Relation Operators (Unary)}
\mydef{Rename}{
    Changes the schema of the relation $R$ by renaming attribute $A_1$ to $B_1$ and so on. $\rho_{(B1, \cdots, B_n \leftarrow A_1, \cdots, A_n)}(R)$. SQL: \texttt{SELECT a AS b FROM R AS R1}
}

\mydef{Selection}{
  $\sigma_C(R) = \set{t \in R \mid C(t)}$ is the set of all tuples in $R$ that satisfy the condition $C$.\\
  The condition $C$ is a Boolean expression composed of predicates:
  \[
  C = P_1\ \mathit{op}_1\ P_2\ \mathit{op}_2\ \cdots\ \mathit{op}_{n-1}\ P_n
  \]
  where each operator $\mathit{op}_i \in \{\text{AND},\ \text{OR},\ \text{NOT}\}$, and each predicate $P_i$ has the form:
  \[
  P_i ::= A\ \theta\ B \quad \text{or} \quad A\ \theta\ c
  \]
  with attributes $A$, $B$, constant $c$, and comparison operator $\theta \in \{=,\ <,\ \leq,\ >,\ \geq,\ \neq\}$.
}

SQL Equiv. : \texttt{SELECT * FROM R WHERE C}

\mydef{Projection}{
    $\Pi_Y(R) = \set{t[Y] \mid t \in R}$. SQL: \texttt{SELECT Y FROM R}
}

\mydef{Idempotent}{
  An operator $\mathcal{O}$ is called \emph{idempotent} if applying it multiple times has the same effect as applying it once: $\mathcal{O}(\mathcal{O}(x)) = \mathcal{O}(x) \quad \forall x$. \textbf{Projection} is \textit{Idempotent}
}


\minititle{Relation Operators (Binary)}
\mydef{Theta Join}{
    $R_1 \Join_C R_2 = \set{t_1 \circ t_2 \mid t_1 \in R_1 \land t_2 \in R_2 \land C(t_1 \circ t_2)} = \sigma_C(R_1 \times R_2)$
}

\textbf{Example:} \texttt{SELECT * FROM Employee JOIN Bonus ON Employee.salary > Bonus.threshold}
\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
id & salary \\
\hline
1 & 50000 \\
2 & 30000 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|}
\hline
threshold \\
\hline
20000 \\
40000 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|}
\hline
id & salary & threshold \\
\hline
1 & 50000 & 20000 \\
1 & 50000 & 40000 \\
2 & 30000 & 20000 \\
\hline
\end{tabular}
\end{array}
\]

\mydef{Equi-Join}{
    Theta Join with $C$ consists only of equality comparison.
}

\textbf{Example:} \texttt{SELECT * FROM Orders JOIN Customers ON Orders.cust\_id = Customers.id}

\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
order\_id & cust\_id \\
\hline
101 & 1 \\
102 & 2 \\
103 & 4 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|}
\hline
id & name \\
\hline
1 & Alice \\
2 & Bob \\
3 & Carol \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|c|}
\hline
order\_id & cust\_id & id & name \\
\hline
101 & 1 & 1 & Alice \\
102 & 2 & 2 & Bob \\
\hline
\end{tabular}
\end{array}
\]

\mydef{Natural Join}{
    Equi-Join where $C$ is quality on common attributes and duplicate common attributes are removed from the result.
}

\textbf{Example: }\texttt{SELECT * FROM Employee NATURAL JOIN Department}
\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
emp\_id & dept\_id \\
\hline
1 & 10 \\
2 & 20 \\
3 & 10 \\
4 & 40 \\
5 & 50 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|}
\hline
dept\_id & name \\
\hline
10 & HR \\
20 & IT \\
30 & Sales \\
60 & Legal \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|}
\hline
emp\_id & dept\_id & name \\
\hline
1 & 10 & HR \\
2 & 20 & IT \\
3 & 10 & HR \\
\hline
\end{tabular}
\end{array}
\]

\mydef{Outer Join}{
    Natural Join but preserves unmatched tuples by padding them with NULL values. That can be done on the relation on the left, right or both.
}

\mydef{Left Outer Join}{
    Includes all tuples from the left relation, padding unmatched right-side tuples with NULLS.
}

\textbf{Example: }\texttt{SELECT * FROM Orders LEFT OUTER JOIN Customers ON Orders.cust\_id = Customers.id}
\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
order\_id & cust\_id \\
\hline
101 & 1 \\
102 & 2 \\
103 & 4 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|}
\hline
id & name \\
\hline
1 & Alice \\
2 & Bob \\
3 & Carol \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|c|}
\hline
order\_id & cust\_id & id & name \\
\hline
101 & 1 & 1 & Alice \\
102 & 2 & 2 & Bob \\
103 & 4 & \text{NULL} & \text{NULL} \\
\hline
\end{tabular}
\end{array}
\]

\mydef{Right Outer Join}{
    Includes all tuples from the right relation, padding unmatched left-side tuples with NULLS.
}

\textbf{Example: }\texttt{SELECT * FROM Orders RIGHT OUTER JOIN Customers ON Orders.cust\_id = Customers.id}
\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
order\_id & cust\_id \\
\hline
101 & 1 \\
102 & 2 \\
103 & 4 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|}
\hline
id & name \\
\hline
1 & Alice \\
2 & Bob \\
3 & Carol \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|c|}
\hline
order\_id & cust\_id & id & name \\
\hline
101 & 1 & 1 & Alice \\
102 & 2 & 2 & Bob \\
\text{NULL} & \text{NULL} & 3 & Carol \\
\hline
\end{tabular}
\end{array}
\]

\mydef{Full Outer Join}{
    Includes all tuples from both relations, padding unmatched tuples from either side with NULLS.
}
\textbf{Example: }\texttt{SELECT * FROM Orders FULL OUTER JOIN Customers ON Orders.cust\_id = Customers.id}
\[
\begin{array}{ccc}
\begin{tabular}{|c|c|}
\hline
order\_id & cust\_id \\
\hline
101 & 1 \\
102 & 2 \\
103 & 4 \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|}
\hline
id & name \\
\hline
1 & Alice \\
2 & Bob \\
3 & Carol \\
\hline
\end{tabular}
&
\begin{tabular}{|c|c|c|c|}
\hline
order\_id & cust\_id & id & name \\
\hline
101 & 1 & 1 & Alice \\
102 & 2 & 2 & Bob \\
103 & 4 & \text{NULL} & \text{NULL} \\
\text{NULL} & \text{NULL} & 3 & Carol \\
\hline
\end{tabular}
\end{array}
\]

\minititle{Operators Properties}
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|c|c|c|c|}
\hline
\textbf{Operator} & \textbf{Result Schema} & \textbf{Result Size} & \textbf{Comm.} & \textbf{Assoc.} & \textbf{Idem.} & \textbf{Duplicates} \\
\hline
Union & Same as inputs & $\leq |R| + |S|$ & Yes & Yes & No & No \\
\hline
Intersection & Same as inputs & $\leq \min(|R|, |S|)$ & Yes & Yes & Yes & No \\
\hline
Difference & Same as $R$ & $\leq |R|$ & No & No & No & No \\
\hline
Cartesian Product & $R \cup S$ & $|R| \cdot |S|$ & Yes & Yes & No & Yes \\
\hline
Rename & Same & $|R|$ & N/A & N/A & N/A & N/A \\
\hline
Selection & Same as $R$ & $\leq |R|$ & Yes & Yes & No & Yes \\
\hline
Projection & Subset of $R$ & $\leq |R|$ & No & No & Yes & No \\
\hline
Theta Join & $R \cup S$ & $[0,\ |R| \cdot |S|]$ & No & No & No & Yes \\
\hline
Equi-Join     & $R \cup S$ & $[0,\ |R| \cdot |S|]$ & No & No & No & Yes \\
\hline
Natural Join & $R \cup S\setminus C$ & $[0,\ |R| \cdot |S|]$ & Yes & Yes & No & Yes \\
\hline
Left Outer Join & $R \cup S$ & $\geq |R|$ & No & No & No & Yes \\
\hline
Right Outer Join & $R \cup S$ & $\geq |S|$ & No & No & No & Yes \\
\hline
Full Outer Join & $R \cup S$ & $\geq \max(|R|, |S|)$ & No & No & No & Yes \\
\hline
\end{tabular}
\end{table}


\minititle{Common Datatypes}
\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Category} & \textbf{Common Data Types} \\ \hline
Numeric           & INT, BIGINT, DECIMAL(p,s), FLOAT, DOUBLE \\ \hline
Character         & CHAR(n), VARCHAR(n), TEXT                 \\ \hline
Date/Time         & DATE, TIME, TIMESTAMP, DATETIME           \\ \hline
Boolean           & BOOLEAN / BOOL                             \\ \hline
\end{tabular}
\end{table}

\newpage
\minititle{Algebra to SQL Example}
\[
\pi_{\text{supplier\_name},\ \text{product\_name}} \left(
  \sigma_{\text{price} > 50} \left(
    \left(
      \text{Suppliers} \bowtie_{\text{supplier\_id}} \text{Products}
    \right)
    \bowtie_{\text{category\_id}} \text{Categories}
  \right)
\right)
\]

\begin{verbatim}
WITH SupplierProducts AS (
    SELECT 
        s.supplier_name, 
        p.product_name, 
        p.price, 
        p.category_id
    FROM Suppliers s
    JOIN Products p ON s.supplier_id = p.supplier_id
),
Filtered AS (
    SELECT * FROM SupplierProducts WHERE price > 50
)
SELECT f.supplier_name, f.product_name
FROM Filtered f
JOIN Categories c ON f.category_id = c.category_id;
\end{verbatim}

\end{document}

